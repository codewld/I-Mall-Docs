# 身份验证及访问控制

## 一、技术栈

* Spring Security
* JWT
* Redis



## 二、基本概念

* 用户，对应使用者，每个用户可以拥有多个角色
* 角色，每个角色可以拥有多个权限
* 权限，当前版本为页面级权限，一个权限对应前端的一个页面和后端的一个 Controller



## 三、Spring Security
待更新




## 四、JWT

### 1. 作用

JWT 有着自鉴权的特点，因此可以在不耗费服务器内存空间（存储 Session）的情况下实现认证。



### 2. 存储内容

JWT 中存储 `ID、username、角色ID列表、签发时间、过期时间` 。



### 3. 为什么不存储权限？

* 如果存储，JWT 体积势必会增大，请求中携带它将极大地耗费网络资源
* 如果存储，当角色所属的权限发生变更时将难以处理
* 每个角色拥有的权限在同一时间是相同的，可以方便地缓存、"轻松" 地获取



## 五、Redis

### 1. 缓存被禁用用户

#### (1) 背景

如果用户被禁用，该用户数据库中的 status 字段将会被设为 true，他将不再能进行任何操作。

用户的禁用需要两部分工作：

* 不得登录：由于登录时本来就要查询数据库，因此只需要简单判断一下用户实体的 status 属性即可
* 不得发送请求：由于 JWT 是自鉴权的，为了能够禁用用户，我们必须额外进行查询数据库的操作，为了减轻数据库负担、提升查询效率，可以利用 Redis 缓存数据库中所有被禁用用户



#### (2) 思路

将当前所有的 "被禁用用户" 缓存，当 `JWTVerifyFilter` 接收到请求时，查询缓存，判断当前用户是否被禁用。



#### (3) 具体实现

* 在 `UmsAdminService` 中增加 `listDisabled()` 方法，它将会向数据库中查询所有被禁用的用户
* 为 `listDisabled()` 方法增加 `@Cacheable(value = "DisabledAdmin")`，使 SpringBoot 自动缓存其结果
* 为 **增、删** 方法添加 `@CacheEvict` 注解，当改动涉及 status 字段时清空缓存
* 在登录状态读取器 `JWTVerifyFilter` 中调用 `listDisabled()` 方法获取所有被禁用用户，判断当前用户是否被禁用



### 2. 使已签发的 JWT 失效

#### (1) 背景

JWT 拥有自校验的特性，这使得它可以自行保存信息，从而替代 Session。

但 JWT 的自校验机制也带来了一个问题，JWT 一旦签发，在其有效期内它将始终有效，这导致用户的认证是不可控的，我们无法实现诸如强制下线某用户的操作。



#### (2) 思路

通过 "外挂校验" 的方式解决。

缓存用户 ID 及最早有效时间（设为当前时间），接收到 JWT 时，判断其是否有对应的缓存，如果有，判断其是否早于最早有效时间颁发，如果是，则要求重新登录。

如此，我们便实现了将已签发的 JWT 强制失效，要求用户重新登录的愿望。



#### (3) 具体实现

* 在 `UmsAdminService` 中增加 `invalidateIssuedJWT(Long id)` 方法，它接收用户 ID，并将用户 ID 及当前时间存储进缓存之中
* 在 `UmsAdminService` 中增加 `isJWTInvalidated(Long id, Long time)` 方法，它接收用户 ID 及 JWT 的签发时间，返回 JWT 是否失效
* 在我们希望 JWT 失效的典型场景，例如删除用户、修改密码，调用 `invalidateIssuedJWT(Long id)` 方法使已签发的 JWT 失效
* 在登录状态读取器 `JWTVerifyFilter` 中，首先解析获得用户 ID 及签发时间，然后调用 `isJWTInvalidated(Long id, Long time)` 判断 JWT 是否失效



### 3. 缓存角色对应的权限

#### (1) 背景

`JWTVerifyFilter` 负责解析请求中的 JWT、读取登录状态。

当 `JWTVerifyFilter` 接收到请求时，需要根据 JWT 中存储的角色信息获取当前用户所拥有的权限，并将权限信息提供给 Spring Security 框架。



#### (2) 思路

将每个角色（通过 ID 标识）对应的权限信息缓存，当接收到请求时，遍历角色信息，获取每个角色对应的权限，对所有的权限信息进行整合、去重处理，放入 Spring Security 安全上下文之中。



### 4. 缓存菜单

#### (1) 背景

在本系统中，用户登录后需要请求 `/account/router` 接口以获取当前用户的路由信息，从而构建前端系统。

该接口的访问是较为高频的，且一次访问可能会多次查询数据库，因此缓存是十分有必要的。



#### (2) 思路

首先，后端会根据 Spring Security 安全上下文中的权限信息获取用户所能访问的页面，因此应该缓存由编码查询的菜单；

其次，为了组合为树形，会递归地根据 parentId 查询父级菜单，因此应该缓存由 ID 查询的菜单。



## 六、几个小问题

### 1. 角色对应的权限发生更新怎么办？

JWT 中并不携带权限信息，而是通过角色信息向缓存获取，我们只需要适时清空缓存重新获取，便可以保证角色对应的权限信息真实有效。



### 2. 用户路由发生更新怎么办？

首先理清一个概念，本系统中路由同时指代系统导航栏及 Vue Router 中的路由，它们均由相同的路由信息生成。

本系统采取了动态路由的方式，用户登录成功后应首先向 "路由接口" 发送请求，后端将会通过 `用户 - 角色 - 权限 - 路由` 的方式生成路由信息并返回。

后端可以保证的是每次请求 "路由接口" 时都可以获取到最新的路由信息，但结合前端便会出现一些问题：

* 如果不对路由信息进行持久化，可以尽可能地保证路由信息的及时性，但每次刷新页面都需要重新获取路由，这将极大地耗费网络资源
* 如果对路由信息进行持久化，路由信息将会被存储在浏览器会话存储空间中，刷新页面无需重新获取，但可能会导致路由信息不及时

综合考虑下，本系统选用了对路由信息持久化的方法，原因如下：

* 角色对应权限的改动不是很频繁，没有必要为此平白耗费网络资源
* 如果用户的权限进行扩充，路由未发生及时更新，推荐的解决方案是让用户重新登录
* 如果用户的权限进行缩窄，路由未发生及时更新，如果用户进入了已经不属于它的页面，后端会返回 "权限验证错误状态码"，前端重新进行路由信息的获取



### 3. 用户对应的角色发生更新怎么办？

使用户对应的已签发的 JWT 失效，要求重新登陆。



### 4. 用户发生更新怎么办？

用户信息的修改分为以下几种情况：

#### (1) 基本信息修改

在本系统中，JWT 作为认证凭据而非信息来源，因此用户信息的更改（包括用户名）无需反映到 JWT 之上。



#### (2) 密码修改

如果修改了 password 字段，便是进行了密码修改，此时应使用户对应的已签发的 JWT 失效，要求重新登陆。



#### (3) 用户禁用

如果修改了 status 字段，将用户禁用，此时应该更新缓存中的禁用用户名单。





